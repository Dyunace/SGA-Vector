// Vector v0.3
#include <iostream>

using namespace std;

// 1. 데이터 추가 (새로운 공간 확보)
// 2. 데이터 삭제
// 3. 데이터를 삽입할 수 있는 공간의 크기
// 4. 현재 삽입되어 있는 원소의 갯수
// 5. 컨테이너의 시작 지점
// 6. 컨테이너의 종료 지점

int main(void)
{
	/*
	int n = 16;

	// 일반적으로는 덧셈식이 더 좋다. 양수를 음수로 바꾸는데 시간이 걸리기 때문
	// n += -6;		// n -= 6;
	printf_s("%d", n);
	*/
	
	// n * 0.5f; 마찬가지로 곱셈이 나눗셈보다 더 좋다.
	// 대입 연산자를 쓰면 빠르게 계산이 가능하다.
	// printf_s("%d", n << 1);	// 두배로 곱하기
	// printf_s("%d", n >> 1);	// 반으로 나누기

	/* 
		// 나누기를 해야할 때에는 *로 대체할 수 있을지 확인해보고
		int n = 1920 / 2;
		// int n = 1920 * 0.5f

		printf_s("%d", n);

		// 아래와 같이 쉬프트 연산자로 사용할 수 있을 지 확인해보자.
		// printf_s("%d", n >> 1);
	*/

	// 2의 보수
	/*
		00010000 = 16
		00000110 = -6
		
		2의 보수			=> 1의	보수를 두 번 진행한다.
		0 0 0 0 0 1 1 0		= 6
		1 1 1 1 1 1 1 1		각 수를 따로 떨어뜨려 1씩 더한다. (1의 보수)
		===============		반올림은 하지 않는다.
		1 1 1 1 1 0 0 1		
		11111001 + 1		결과값에 1을 더한다. (1의 보수)
		= 11111010			= -6 (총 합 2의 보수)
		
		  00010000 = 16
		+ 11111010 = -6
		================
		  00001010 = 10
	*/

	// =========================================================
	// =========================================================

	// 벡터의 크기를 지정할 때는 2의 제곱값으로 지정하는게 좋다.
	/*
	int Vector[16];

	int Max = 10;
	for ( int i = 0; i < Max; i++ )
		cout << Vector[i] << endl;
	*/

	/*
	// 배열은 0이 아닌 값으로만 초기화가 가능하다.
	// 배열은 상수값으로만 초기화가 가능하다.

	// 아래와 같이 사용한다면 위 조건은 무시할 수 있다.

	int Size = 0;
	int iter = 0;
	int* Vector = new int[Size];

	Vector[iter];
	*/

	// 배열은 아니지만 배열처럼 쓸 수 있다.
	int Size = 10;
	int iter = 0;
	int* Vector = new int[Size];

	for (int i = 0; i < Size; ++i)
		Vector[i] = i;

	for (int i = 0; i < 17; ++i)
		cout << Vector[iter++] << endl;

	return 0;
}

// 배열의 장단점
/*
	배열의 장점

	직접 접근이 가능하다.
	 - 데이터를 거쳐가지 않아도 됀다.

	접근 속도가 일정하다.
	 - 동일한 크기의 데이터를 나열하기 때문에 속도가 일정하다.


	배열의 단점

	동적 변환이 불가능하다.
	 - 한 번 정한 길이를 변경할 수 없다.
*/

// 배열의 길이
/*
	배열의 길이는 변환이 불가능하다.
	데이터를 추가하고 싶다면 새 배열을 만든 뒤, 기존 데이터를 덮어써야 한다.
	하지만, 데이터를 추가하고 삭제하는 과정에서 부하가 걸릴 수 있다.

	배열을 처음 생성할 때 사용량보다 더 크게 만든다.
*/

// 데이터의 복사
/*
	데이터는 이동보다 복사가 더 빠르다.
	데이터의 이동의 정의는 '데이터를 복사한 후, 기존의 데이터를 삭제'이다.
*/